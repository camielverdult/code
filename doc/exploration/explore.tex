\documentclass{article}
\usepackage{preamble}
\begin{document}
\title{Exploration in \GROOVE}
\author{Arend Rensink}
\date{August 2024}
\maketitle

\section*{Terminology}

The following is a list of properties of states and transitions, marked \textbf{S} and/or \text{T} to signify whether they apply to states, transitions or both. Figure~\ref{fig:venn} shows these different concepts in relation to each other.

\begin{description}
\item[Absence (S)] Equivalent to \emph{absent depth}.

\item[Absent depth (S)] The \emph{absent depth} of a state is the minimal transient depth of that state and all its transitive successors. It follows that the \emph{absent depth} is smaller than or equal to the \emph{transient depth}. As long as a state is not \emph{complete}, its \emph{absent depth} may decrease as a consequence of further exploration.

\item[Absent (S,T)] A state or transition is \emph{absent} if it should not be considered to be part of the state space. In particular, a state is \emph{absent} if it is \emph{complete} and has positive \emph{absent depth}; a transition is \emph{absent} if its target state is \emph{absent}. It follows that an \emph{absent} state is always \emph{transient}. Whether or not a state or transition is \emph{absent} is independent of whether or not it is \emph{inner}.

\item[Atomic (T)] A transition is \emph{atomic} if it is \emph{outer} and consists of a single step, meaning that its source and target states are \emph{steady}.

\item[Closed (S)] A state is \emph{closed} if it is not \emph{open}. A \emph{closed} state may or may not be \emph{complete}.

\item[Complete (S)] A state is \emph{complete} if it is \emph{closed} and all transitive successors up to (but not necessarily including) the first \emph{steady} state are also \emph{closed}. This means that the status of the state is fully known; in particular, it is possible, on the basis of its successors, to decide whether the state is \emph{absent}.

\item[Public (S,T)] A state or transition is \emph{public} if it is both \emph{outer} and \emph{present} (or, in other words, if it is neither \emph{inner} nor \emph{absent}).

\item[Final (S)] A state is \emph{final} if exploration is considered to terminate after reaching it. For instance, if two control blocks are concatenated, the second comes into play after the exploration of the first has reached a final state; also, if a state space is wrapped in an atomic block, the only \emph{steady} states, apart from the \emph{initial} state, are the \emph{final} ones. In other words, \emph{final} has the typical meaning in (regular) automata. A \emph{final} state is certainly \emph{closed} and \emph{steady}; it may or may not have successors.

\item[Initial (S)] A state is \emph{initial} if it is the start state for the exploration. Its \emph{prime} is \emph{steady}.

\item[Short (S)] A state is \emph{short} if it is not \emph{complete}.

\item[Inner (S,T)] A state is \emph{inner} if it is inside the atomic block that makes up the body of a recipe, and a transition is \emph{inner} if it is a step in the execution of a recipe. Hence, an \emph{inner} state is certainly \emph{transient}, but the inverse does not hold. An \emph{inner} state that is not \emph{closed} may still evolve into an \emph{outer} one as a consequence of further exploration.

\item[Open (S)] A state is \emph{open} if its direct outgoing transitions are not fully known. It follows that an open state can become \emph{closed} through further exploration of its outgoing transitions.

\item[Outer (S,T)] A state or transition is \emph{outer} if it is not \emph{inner}.

\item[Partial (T)] A transition is \emph{partial} if it is part of an atomic block. Apart from the \emph{inner} transitions, the \emph{partial} ones include single-step recipe executions.

\item[Present (S,T)] A state or transition is \emph{present} if it is not \emph{absent}. For a state, this means that it either has \emph{absent depth} zero (in which case it will certainly remain \emph{present} under further exploration) or it is \emph{short} (in which case it may become \emph{absent} if, upon becoming \emph{complete}, it has positive \emph{absent depth}).

\item[Prime (S)] The \emph{prime} of a state is the version of that state when it is just discovered, and no outgoing transitions have been explored. Hence, the \emph{prime} is \emph{open}, and may be \emph{transient} even though (because of further exploration) the state itself has become \emph{steady} because its \emph{transient depth} has decreased to zero.

\item[Public (S,T)] A state or transition is \emph{public} if it is both \emph{outer} and \emph{present}.

\item[Steady (S)] A state is \emph{steady} if it is not \emph{transient}.

\item[Transience (S)] Equivalent to \emph{transient depth}.

\item[Transient (S)] A state is \emph{transient} if it is inside an atomic block, meaning that it has a positive \emph{transient depth}. A \emph{transient} state may or may not be \emph{inner}. A transient state that is \emph{open} may still evolve into a \emph{steady} state as a consequence of further exploration.

\item[Transient depth (S)] The \emph{transient depth} of a state is the number of (nested) atomic blocks that it is inside of. A state is \emph{steady} if and only if its \emph{transient depth} is zero; otherwise it is \emph{transient}. As long as a state is not \emph{closed}, its \emph{transient depth} may decrease as a consequence of further exploration.
\end{description}

\begin{figure}
\centering
\begin{subfigure}{0.45\textwidth}
\centering
\includegraphics[scale=.4]{figs/s-venn}
\caption{Stats}
\end{subfigure}%
\begin{subfigure}{0.3\textwidth}
\centering
\includegraphics[scale=.4]{figs/t-venn}

\bigskip
\caption{Transitions}
\end{subfigure}%
%
\begin{subfigure}{.25\textwidth}
\scalebox{.8}{$\begin{array}[b]{@{}r@{{\;\equiv\;}}l@{}}
\mathit{inner} & \neg\mathit{outer} \\
\mathit{short} & \neg\mathit{complete} \\
\mathit{open} & \neg\mathit{closed} \\
\mathit{partial} & \neg\mathit{atomic} \\
\mathit{present} & \neg\mathit{absent} \\
\mathit{public} & \mathit{outer} \\
\multicolumn{2}{r}{{}\wedge\mathit{present}} \\
\mathit{transient} & \neg\mathit{steady}
\end{array}$}

\bigskip
\phantomcaption
\end{subfigure}
\caption{Properties of states and transitions}
\label{fig:venn}
\end{figure}


\section*{State spaces}

\medskip\noindent
We globally assume a set of labels $A$.

\medskip\noindent 
A \emph{state space fragment} is a tuple $\cS=\tupof{S,\Init,{\trans{}},{\final},\TLevel,\Open}$ with
\begin{itemize}
\item $S$ a set of states;
\item $\Init\in S$ the initial state;
\item ${\trans{}}\subseteq S\times A\times S$ a transition relation;
\item ${\final}\subseteq S$ a termination predicate;
\item ${\TLevel}:S\to \natN$ a \emph{transience level} function, such that $\TLevel(\Init)=0$;
\item $\Closed\subseteq S$ a set of \emph{closed states}, such that $\final\subseteq \Closed$.
\end{itemize}
%
$\cS$ is called \emph{complete}, or just a \emph{state space}, if $\Closed=S$. A state $s\in S$ is called \emph{final} if $s\final$. We also use a number of auxiliary concepts for states $s\in S$:

\begin{itemize}
\item $\Transient(s)$ expresses that $s$ is \emph{transient}. It is defined by
%
\[ \Transient = \gensetof{s\in S}{\TLevel(s)>0} \enspace. \]

\item $\Steady(s)$ expresses that $s$ is \emph{steady}, which is the inverse of $\Transient(s)$.

\item $\Complete(s)$ expresses that $s$ is \emph{complete}, meaning that $s$, as well as all its $\trans{}$-successors up to and including the first steady state are closed. $\Complete$ is defined as the smallest set such that
%
\[ \Complete = \Closed\cap \bigl(\Steady \cup \gensetof{s\in S}{\forall s\trans{} s'.\, s'\in \Complete\cup \Steady}\bigr) \enspace.
\]
It follows that, if $\cS$ is complete, $\Complete=S$.

\item $\ALevel[C](s)$ is the \emph{absence level} of $s$, meaning the minimum transient depth of $s$ and all its $\trans{}$-successors. It is defined by
%
\[ \ALevel: s\mapsto \min\gensetof{\TLevel(s')}{s\trans{}^* s'} \enspace. \]

\item $\Absent(s)$ expresses that $s$ is \emph{absent}, which is the case if there is no steady state reachable from $s$. It is defined by
%
\[ \Absent= \gensetof{s}{\ALevel(s)>0} \enspace. \]
\end{itemize}

\section*{Pseudo-state spaces}

State spaces are generated from a \emph{pseudo-state spaces}.

\medskip\noindent
A pseudo-state space is a tuple $\cP=\tupof{P,\Init,{\goto},{\mapsto},{\pfinal},\TLevel,\Recipe}$ with
\begin{itemize}
\item $P$ a finite set of pseudo-states;
\item $\pInit\in P$ the initial pseudo-state;
\item ${\gotoeq}\subseteq P\times P$ a partial order relation called \emph{evolution};
\item ${\step{}}\subseteq P\times A\times P$ a ternary \emph{step relation};
\item ${\pfinal} \subseteq P$ a pseudo-termination predicate;
\item ${\pTLevel}:P\to \natN$ a transience level function;
\item ${\OLevel}:P\to \natN$ an \emph{outer level} function, such that $\OLevel(p)\leq \TLevel(p)$ for all $p\in P$;
\item $\Recipe:A\pto A$ a partial \emph{recipe mapping}.
\end{itemize}
%
Hence, with respect to a state space, the transition relation is replaced by evolution in combination with a step relation, the $\Closed$ predicate has disappeared (instead it is derived from $\gotoeq$) and there are two new components that encode a special kind of atomic block called a \emph{recipe}. A pseudo-state $p\in P$ is called
%
\begin{itemize}
\item \emph{Prime} (denoted $\pPrime(p)$) if $p$ is a $\gotoeq$-minimum;
\item \emph{Closed} (denoted $\pClosed(p)$) if $p$ is a $\gotoeq$-maximum;
\item \emph{Open} (denoted $\pOpen(p)$) if it is not closed;
\item \emph{Outer} (denoted $\pOuter(p)$) if $\OLevel(p)=\TLevel(p)$;
\item \emph{Inner} (denoted $\pInner(p)$) if it is not outer.
\end{itemize}
%
Moreover, \emph{transience} and its complement, \emph{steadiness} ($\Transient$ and $\Steady$, respectively) are defined using $\TLevel$ as for state space fragments. A pseudo-state space is \emph{well-formed} if it satisfies the following additional properties:
%
\begin{itemize}
\item Evolution is piecewise linear; i.e., every pseudo-state has at most one direct $\prec$-predecessor and at most one direct $\prec$-successor. We use ${\gostep}\subseteq {\gotoeq}$ to denote the direct successor-subrelation and $\inc p$ to denote the $\gostep$-successor of $p$ (which is therefore not always defined).

\item Stepping is deterministic; i.e., $\step{}$ is a partial function from $P$ to $A\times P$. We use $a_p$ and $\scs p$ to denote the outgoing transition and successor state of $\step{}$, if defined; hence $p\step{a_p} \scs p$ if $\step{}$ is defined for source $p$.

\item All steps go from open to prime pseudo-states; i.e., $p\step{}q$ implies $\pOpen(p)$ and $\pPrime(q)$.

\item All final pseudo-states are steady and closed; i.e., $p\pfinal$ implies $\pSteady(p)$ and $\pClosed(p)$.

\item Evolution cannot increase transience; i.e., $p\goto q$ implies $\pTLevel(q)\leq \pTLevel(p)$.

\item For all $\pOuter$ pseudo-states, all $\gotoeq$- and $\step{}$-successors that do not start a recipe are $\Outer$: i.e., if $\pOuter(p)$ and either $p\gostep q$ or $p\step a q$ with $a\notin\dom\Recipe$ then $\OLevel(q)=\TLevel(q)$ (and hence $\pOuter(q)$).

\item For all $\pOuter$ pseudo-states, their outer level is frozen for all $\step{}$-successors that start a recipe, unless it exceeds that successor's transience level: i.e., if $\pOuter(p)$ and $p\step a q$ with $a\in\dom\Recipe$ then $\OLevel(q)=\min(\TLevel(p),\TLevel(q))$.

\item For all $\pInner$ pseudo-states, their outer level is kept constant for all $\gotoeq$- and $\step{}$-successors, unless it exceeds that successor's transience level: i.e., if $\pInner(p)$ and either $p\gostep q$ or $p\step{} q$ then $\OLevel(q)=\min(\OLevel(p),\pTLevel(q))$.
\end{itemize}
%
(The last three conditions together with the fact that $\OLevel(\Init)\leq \TLevel(\Init)=0$ actually completely define $\OLevel$ for all reachable pseudo-states.) 
From now on, we only deal with well-formed pseudo-states spaces. The \emph{prime of} and \emph{closure of} an arbitrary pseudo-state $p$ are defined as
%
\begin{align*}
	\prm p & = q \quad \text{where $\pPrime(q)$ and $q\gotoeq p$} \\
	\cls p & = q \quad \text{where $p\gotoeq q$ and $\pClosed(q)$} \enspace.
\end{align*}
%
Note that these are well-defined because $P$ is finite and $\gotoeq$ is piecewise linear.

The recipe mapping $\Recipe$ of a pseudo-state space encodes that an $a$-labelled step for $a\in\dom\Recipe$ kicks off the execution of recipe $\Recipe(a)$ (of which $a$ is the initial partial step). That is, a step $p\step a q$ for which $a\in \dom\Recipe$ gives rise to a $\Recipe(a)$-labelled \emph{recipe transition} in the derived state space, which is considered to be finished upon reaching the first \Outer successor $q'$ of $q$ (possibly $q'=q$); unless, that is, $p\step a q$ is itself part of an ongoing recipe transition --- in other words, recipe transitions are not nested. If $a\notin\dom \Recipe$, on the other hand, $p\step a q$ gives rise to an $a$-labelled ``simple'' transition in the derived state space. To capture recipe transitions, we define:
%
\begin{align*}
p \innerstep q \;\iffdef\; 
 & p\in \pInner \wedge (p\step{} q\vee p\gostep q) \\
p \tstep{a} q \;\iffdef\;
 & p\in \pOuter \wedge a\in\dom\Recipe \wedge p\step a{} q \enspace.
\end{align*}
%
Hence, $p\innerstep q$ (``$p$ has an $\Inner$-step to $q$'') if $p$ is an inner pseudo-state that either has a single labelled step or a single evolution step to $q$, and $p\tstep a q$ (``$p$ has an initial recipe-transition to $q$) if $p$ is an outer pseudo-state with an outgoing recipe-initiating step to $q$ --- which may be inner or outer. We write $\innerto$ for the transitive closure and $\innertoeq$ for the transitive and reflexive closure of $\innerstep$. As we will see, every sequence $p\tstep a\:\innertoeq q\in \Outer$ will give rise to a $\Recipe(a)$-labelled recipe transition.

A pseudo-state space represents a state space in which the states effectively correspond to $\gotoeq$-ordered sets of pseudo-states (which are actually chains because $\gotoeq$ is piecewise linear). Rather than formalising the relation in this way, however, we let a state be represented by the initial element of such a chain, i.e., by the (unique) prime pseudo-state.

\section*{Configurations}

Given a pseudo-state space $\cP$ as above, a \emph{configuration} is set $C\subseteq P$ of pseudo-states with $\pInit\in C$ that is $\gotoeq$-left-closed and such that, moreover, $p\in C$ with $p\comefrom\:\step{} q$ implies $q\in C$. (It follows that $P$ is itself a configuration of $\cP$.) We use $\step[C]{}$, $\gotoeq[C]$, $\innerstep[C]$ and $\tstep[C]{}$ to denote the restrictions of the corresponding relations $\step[\cP]{}$ etc.\ to $C$.

Every configuration $C$ generates a state space $\cS_C= \tupof{S_C,\Init[C],\trans[C]{}, \final_C, \TLevel[C]}$, in which the states are always $\evolequiv$-equivalence classes of pseudo-states, i.e., elements of $P/{\evolequiv}$. For a given $p\in P$ we use $\stat p$ as an abbreviation of the equivalence classe $\stat p_\evolequiv$. This is extended pointwise to subsetes $Q\subseteq P$, i.e., $\stat Q=\gensetof{\stat p}{p\in Q}$. (Note that this is in general \emph{not} the same as $Q/{\evolequiv}$.)

The components of $\cS_C$ are then defined as follows:
%
\begin{align*}
S_C & = \stat{\pOuter\cap C} \\
\Init[C] & = \stat{\pInit} \\
{\trans[C]{}} & = \gensetof{(\stat p,a,\stat q)}{p\in \pOuter, a\notin\dom\Recipe, p\step[C] a q} \\
&\phantom{=} {}\cup \gensetof{(\stat p,\Recipe(a),\stat{q})}{p\tstep[C]{a}\: \innertoeq[C] q\in \pOuter} \\
\final_C & = \stat{\pfinal\cap C} \\
\TLevel[C] & : s \mapsto \min \gensetof{\pTLevel(p)}{p\in s\cap C} \enspace \text{for all $s\in S_C$} \\
\Closed[C] & = \stat{\pClosed \cap \pOuter\cap C} \enspace.
\end{align*}
%
We also use $\Steady[C]$, $\Complete[C]$, $\ALevel[C]$ and $\Absent[C]$ to denote $\Steady[\cS_C]$ etc.

\medskip\noindent
We want to construct $S_P$ incrementally by approaching $P$ through a sequence of configurations, starting with $\setof{\Init}$ and exploring, at each iteration, an open pseudo-state $p\in\Open[C]$. This exploration step is defined by 
%
\[ C\oplus p = C\cup \setof{\inc p} \cup \gensetof{\scs p}{p\step{}} \enspace. \]
%
Incremental construction means that, if $D=C\oplus p$, all components of $S_D$ can be constructed from $S_C$ and $\cP$. Indeed, we have
%
\begin{align*}
\final_D & = \final_C \cup \stat{(D\setminus C) \cap \pfinal} \\
\TLevel[D] & : s\mapsto
  \begin{cases}
  \pTLevel(q) & \text{if } s\in\stat{D\setminus C} \\
  \TLevel[C](s) & \text{otherwise}
  \end{cases} \\
  \Closed[D] & = \Closed[C] \cup \stat{(D\setminus C)\cap \pClosed} \enspace.
\end{align*}
%
The incremental constuction of $\trans[D]{}$, however, is much less straightforward, especially for recipe transitions, due to the fact that the relation $\tstep{}$ may go through many intermediate steps. The following equality holds (with $D=C\oplus p$ as before):
%
\begin{align}
{\trans[D]{}}  = {} & {\trans[C]{}} \nonumber \\
& {}\cup \gensetof{(\stat p,a, \stat q)}{p\in \pOuter, p\step a q,a\notin\dom\Recipe} \\
& {}\cup \gensetof{(\stat{p},\rho(a), \stat q)}{p\tstep a q\in \pOuter} \\
& {}\cup \gensetof{(\stat{q_1},\rho(a),\stat{q_2})}{p_1\tstep[C]{a} \:\innertoeq[C] p\in\pInner, \scs p \innerstep[C] q_2 \in\pOuter} \\
& {}\cup \gensetof{(\stat{q_1},\rho(a),\stat{\inc p})}{p_1\tstep[C]{a} \:\innertoeq[C] p\in\pInner, \inc p\in\pOuter} \enspace.
\end{align}
%
The cases in this equation can be explained as follows. The evolution of $p$ to $p'$, which may include the discovery of a step $p\step a q$, may give rise to new transitions in $\cS_D$ according to one of these five principles:
%
\begin{enumerate}[label=(\arabic*)]
\item A ``normal'' (non-recipe) transition $\stat p\trans a \stat q$;

\item A recipe transition $\stat p\trans{\rho(a)} \stat q$ due to a pseudo-state sequence starting at $p$, consisting of a single inner step $p\step a q$ and ending at $q\in \Outer[D]$ (where the latter may or may not have been in $C$ already);

\item\label{successor construction} A recipe transition $\stat{q_1} \trans{\rho(a)} \stat{q_2}$ for every previously found outer pseudo-state $q_1\in C$, provided $p$ was already reachable from $q_1$ in $C$ via a sequence $q_1\tstep[C]{a}\:\innertoeq[C]\cdots\innerstep[C] p$ (going only through $\pInner$-pseudo-states) and $q_2$ was already reachable from $\scs p$ via a further sequence $p\step{} \innerstep[C] q_2$ (note that this includes $q_2=\scs p$), such that, moreover, $\pOuter(q_2)$;

\item\label{increment construction} A recipe transition $\stat{q_1} \trans{\rho(a)} \stat{\inc p}$ for every previously found outer pseudo-state $q_1\in \pOuter$, provided $p$ was already reachable from $q_1$ in $C$ via a sequence $q_1\tstep[C]{a}\:\innerstep[C]\cdots\innerstep[C] p$ (going only through $\pInner$-pseudo-states) that now gets extended with the evolution $p\gostep[D] \inc p$ with $\pOuter(\inc p)$.
\end{enumerate}
%
Clearly, the reason why the above equation does not give rise to a straightforward incremental construction is that the possible values of $q_1$ in Cases \ref{successor construction}--\ref{increment construction} as well as $q_2$ in Case~\ref{successor construction} are not a priori known. This is resolved by introducing auxiliary functions:
%
\begin{itemize}
\item $\PastOut[C]:P\to 2^P$, the \emph{past outer pseudo-states}, defined by
\[ \PastOut[C] : p \mapsto \gensetof{q\in\pOuter}{q\tstep[C]{} \:\innertoeq[C] p\in\pInner} \enspace. \]
\item $\ReachOut[C]:P\to 2^P$, the \emph{reachable outer pseudo-states}, defined by
\[ \ReachOut[C] : p \mapsto \gensetof{q\in\pOuter}{p\innertoeq[C] q} \enspace. \]
\item $\PastIn[C]:P\to 2^P$, the \emph{past inner pseudo-states}, defined by
\[ \PastIn[C] : p \mapsto \gensetof{q\in\pInner}{q\innertoeq[C] p\in\pInner} \enspace. \]
\item $\ReachIn[C]:P\to 2^P$, the \emph{reachable inner pseudo-states}, defined by
\[ \ReachIn[C] : p \mapsto \gensetof{q\in\pInner}{p\innertoeq[C] q} \enspace. \]
\end{itemize}
%
Note that these functions are always defined for all pseudo-states, even outside the configuration $C$; in fact, if $p\in P\setminus C$ then $\PastOut[C](p)= \emptyset$, $ \ReachOut[C](p)=\pOuter\cap \setof p$ whereas $\PastIn[C](p)= \ReachIn[C](p)= \pInner\cap \setof p$. With the help of these functions, Clauses \ref{successor construction}--\ref{increment construction} become straightforward to implement; and these functions themselves can also be constructed incrementally. Indeed, the following properties hold for $D=C\oplus p$:
%
\begin{align*}
\PastOut[D] : q \mapsto {}
 & \begin{cases}
 	\PastOut[C](q) \cup \setof{p} & \text{if } p\in\Outer[C] \text{ and } q\in \ReachIn[C](\scs p) \\
 	\PastOut[C](q) \cup \PastOut[C](p) & \text{if } p\in\Inner[C] \text{ and } q\in \setof{\inc p} \cup \ReachIn[C](\scs p) \\
 	\PastOut[C](q) & \text{otherwise}
 \end{cases} \\
\ReachOut[D] : q \mapsto {}
 & \begin{cases}
   \ReachOut[C](q) \cup (\Outer[D]\setminus C) \cup \ReachOut[C](\scs p) & \text{if } q\in \PastIn[C](p) \\
   \ReachOut[C](q) & \text{otherwise} \\
   \end{cases} \\
\PastIn[D] : q \mapsto {}
& \begin{cases}
	\PastIn[C](q) \cup \PastIn[C](p) & \text{if } q\in \setof{\inc p}\cup \ReachIn[C](\scs p) \\
	\PastIn[C](q) & \text{otherwise}
\end{cases} \\
\ReachIn[D] : q \mapsto {}
& \begin{cases}
	\ReachIn[C](q) \cup (\Inner[D]\setminus C) \cup \ReachIn[C](\scs p) & \text{if } q\in \PastIn[C](p) \\
	\ReachIn[C](q) & \text{otherwise.}
\end{cases}
\end{align*}
%
\begin{align*}
\PastOut[D] : q \mapsto {}
 & \begin{cases}
 	\PastOut[C](q) \cup \setof{p} & \text{if } p\in\Outer[C] \text{ and } q\in \ReachIn[C](\scs p) \\
 	\PastOut[C](q) \cup \PastOut[C](p) & \text{if } p\in\Inner[C] \text{ and } q\in \setof{\inc p} \cup \ReachIn[C](\scs p) \\
 	\PastOut[C](q) & \text{otherwise}
 \end{cases} \\
\ReachOut[D] : q \mapsto {}
 & \begin{cases}
   \ReachOut[C](q) \cup (\Outer[D]\setminus C) \cup \ReachOut[C](\scs p) & \text{if } q\in \PastIn[C](p) \\
   \ReachOut[C](q) & \text{otherwise} \\
   \end{cases} \\
\PastIn[D] : q \mapsto {}
& \begin{cases}
	\PastIn[C](q) \cup \PastIn[C](p) & \text{if } q\in \setof{\inc p}\cup \ReachIn[C](\scs p) \\
	\PastIn[C](q) & \text{otherwise}
\end{cases} \\
\ReachIn[D] : q \mapsto {}
& \begin{cases}
	\ReachIn[C](q) \cup (\Inner[D]\setminus C) \cup \ReachIn[C](\scs p) & \text{if } q\in \PastIn[C](p) \\
	\ReachIn[C](q) & \text{otherwise.}
\end{cases}
\end{align*}
%
The incremental construction of $\Complete[C]$, and $\ALevel[C]$ requires similar auxiliary functions. We define step relations ${\absentstep[C]},{\shortstep[C]}\subseteq P\times P$
%
\begin{align*}
p \absentstep[C] q \;\iffdef\; & \Absent[C](p) \wedge (p\step[C] q \vee p\gostep[C] q) \\
p \shortstep[C] q \;\iffdef\; & \Short[C](p) \wedge \Transient[C] q\wedge (p\step[C] q \vee p\gostep[C] q)
\end{align*}
%
and functons $\PastAbs[C],\PastShort[C]:P\mapsto 2^P$
%
\begin{align*}
\PastAbs[C] : p\mapsto & \gensetof{q\in \Absent[C]}{q\absenttoeq[C] p} \\
\PastShort[C] : p\mapsto & \gensetof{q\in \Short[C]}{q\shorttoeq[C] p} \\
\ReachShort[C] : p\mapsto & \gensetof{q\in \Short[C]}{p\shorttoeq[C] q} \enspace.
\end{align*}
%
These functions can be updated incrementally:
%
\begin{align*}
\PastAbs[D] : q \mapsto {}
 & \begin{cases}
 	\PastAbs[C](q) & \text{otherwise}
 \end{cases} \\
\PastShort[D] : q \mapsto {}
 & \begin{cases}
   \PastShort[C](q) & \text{otherwise} \\
   \end{cases} \\
\ReachShort[D] : q \mapsto {}
& \begin{cases}
	\ReachShort[C](q) & \text{otherwise}
\end{cases}
\end{align*}


\end{document}
